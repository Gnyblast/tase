const std = @import("std");
const helper = @import("prune_helper.zig");
const enums = @import("../enum/config_enum.zig");
const TaseNativeErrors = @import("../factory/error_factory.zig").TaseNativeErrors;
const Pruner = @import("./pruner.zig").Pruner;

const Allocator = std.mem.Allocator;

pub fn doTruncate(pruner: Pruner, allocator: Allocator) !void {
    std.log.scoped(.logs).info("Processing file truncates for path: {s}", .{pruner.directory});
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    std.log.debug("Matcher is: {s}", .{pruner.matcher});
    const files = try helper.findRegexMatchesInDir(arena.allocator(), pruner.directory, pruner.matcher);
    std.log.debug("Matched files are: {any}", .{files.items});
    for (files.items) |file_name| {
        var paths = [_][]const u8{ pruner.directory, file_name };
        const path = std.fs.path.join(allocator, &paths) catch |err| {
            std.log.scoped(.logs).err("error joining paths: {s}/{s}, {any}", .{ pruner.directory, file_name, err });
            continue;
        };
        defer allocator.free(path);

        if (helper.shouldProcess(pruner.log_action.@"if".?, path, pruner.timezone)) {
            switch (std.meta.stringToEnum(enums.TruncateFrom, pruner.log_action.truncate_settings.?.from.?) orelse return TaseNativeErrors.InvalidTruncateFromFieldValue) {
                .bottom => {
                    try processForBottom(pruner);
                },
                .top => {
                    try processForTop(pruner);
                },
            }
        }
    }
}

fn processForBottom(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateAction, pruner.log_action.truncate_settings.?.action.?) orelse return TaseNativeErrors.InvalidTruncateActionFieldValue) {
        .keep => try processKeepBottom(pruner),
        .delete => try processDeleteBottom(pruner),
    }
}

fn processKeepBottom(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateBy, pruner.log_action.truncate_settings.?.by.?) orelse return TaseNativeErrors.InvalidTruncateByFieldValue) {
        .size => try keepBottomBySize(pruner),
        .line => try keepBottomByLine(pruner),
    }
}

fn processDeleteBottom(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateBy, pruner.log_action.truncate_settings.?.by.?) orelse return TaseNativeErrors.InvalidTruncateByFieldValue) {
        .size => try deleteBottomBySize(pruner),
        .line => try deleteBottomByLine(pruner),
    }
}

fn keepBottomBySize(pruner: Pruner, file: std.fs.File) !void {
    const size = try file.getEndPos();
    const keep = pruner.log_action.truncate_settings.?.size.?;

    if (keep >= size) return;

    const from = size - keep;
    try shiftForward(&file, from);
}

fn keepBottomByLine(_: Pruner) !void {}
fn deleteBottomBySize(_: Pruner) !void {}
fn deleteBottomByLine(_: Pruner) !void {}

fn processForTop(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateAction, pruner.log_action.truncate_settings.?.action.?) orelse return TaseNativeErrors.InvalidTruncateActionFieldValue) {
        .keep => try processKeepTop(pruner),
        .delete => try processDeleteTop(pruner),
    }
}

fn processKeepTop(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateBy, pruner.log_action.truncate_settings.?.by.?) orelse return TaseNativeErrors.InvalidTruncateByFieldValue) {
        .size => try keepTopBySize(pruner),
        .line => try keepTopByLine(pruner),
    }
}

fn processDeleteTop(pruner: Pruner) !void {
    switch (std.meta.stringToEnum(enums.TruncateBy, pruner.log_action.truncate_settings.?.by.?) orelse return TaseNativeErrors.InvalidTruncateByFieldValue) {
        .size => try deleteTopBySize(pruner),
        .line => try deleteTopByLine(pruner),
    }
}

fn keepTopBySize(pruner: Pruner, file: std.fs.File) !void {
    const keep = pruner.log_action.truncate_settings.?.size.?;
    try file.setEndPos(keep);
}

fn keepTopByLine(_: Pruner) !void {}
fn deleteTopBySize(_: Pruner) !void {}
fn deleteTopByLine(_: Pruner) !void {}

fn shiftForward(file: *std.fs.File, from: u64) !void {
    const end = try file.getEndPos();

    var read_pos = from;
    var write_pos: u64 = 0;

    var buf: []u8 = try std.heap.page_allocator.alloc(u8, buf_size);
    defer std.heap.page_allocator.free(buf);

    while (read_pos < end) {
        try file.seekTo(read_pos);
        const n = try file.read(buf);
        if (n == 0) break;

        try file.writeAll(buf[0..n], write_pos);

        read_pos += n;
        write_pos += n;
    }

    try file.setEndPos(write_pos);
}
